---
title: "**Lockdown Mobility Network Analysis**"
subtitle: "Final project for the Social Network Analysis course"
abstract: "The aim of this project report is to analyze shifts in mobility patterns during Italy's COVID-19 lockdown. More specifically, we consider the Italian mobility network for three specific days during the COVID-19 pandemic outbreak: the beginning of the **first local lockdown** in the Lodi province (25/02/2020), the beginning of **nation-scale lockdown** (03/10/2020) and the **end of nation-scale lockdown** at regional level (05/05/2020). We perform a diachronic descriptive analysis of the mobility network, apply community detection algorithms to highlight mobility shifts at a provincial level and model network connections by the mean of exponential random graphs (ERGs) to show the strong connection between mobility shifts and COVID-19 diffusion statistics. We conclude by comparing our results with the mobility reports publicly released by Google during the lockdown. Our code is available at [https://github.com/gsarti/lockdown-mobility-analysis](https://github.com/gsarti/lockdown-mobility-analysis)"
author: 
- Gabriele Sarti
- Enrico Fallacara
date: "University of Trieste, A.A. 2019/2020"
urlcolor: blue
output: 
  pdf_document:
    fig_crop: no
    fig_caption: yes
    includes:
      in_header: header.tex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
source('src/utils.R')
source("src/plot.R")

mobility_pre <- read.csv('data/2020-02-25.csv',sep=";")
mobility_mid <- read.csv('data/2020-03-10.csv',sep=";")
mobility_post <- read.csv('data/2020-05-05.csv',sep=";")

graph_pre <- create_graph_from_data(mobility_pre, metric="n", loops=F, zeros = F)
graph_mid <- create_graph_from_data(mobility_mid, metric="n", loops=F, zeros = F)
graph_post <- create_graph_from_data(mobility_post, metric="n", loops=F, zeros = F)

graph_pre_all <- create_graph_from_data(mobility_pre, metric="n", zeros=F)
graph_mid_all <- create_graph_from_data(mobility_mid, metric="n", zeros=F)
graph_post_all <- create_graph_from_data(mobility_post, metric="n", zeros=F)
```

## Introduction

The nation-level lockdown implemented by the Italian Government in order to prevent the spreading of the COVID-19 disease in 2020 greatly affected the mobility patterns of roughly 60 millions of Italian citizens and residents. The Italian lockdown was composed by several subsequent phases of tightening and loosening of restrictions, with three most relevant dates arguably being:

- The **first lockdown** of ten municipalities of the province of Lodi, forming the first *zona rossa*, shortly after February 21st, 2020.

- The **national lockdown** that restricted travel at intra-municipal level, except for working necessities and family emergencies, on the evening of March 9th, 2020.

- The **reopening of inter-regional travel** that took place from May 5th, 2020.

In this report, we analyze how the Italian mobility trends have changed during the three phases defined by the aforementioned dates using a dataset containing raw movements *WAIT FOR SPECIFICATIONS* at a macro-scale level. We begin by presenting data and preprocessing steps that were taken in order to perform the analysis in [\textcolor{blue}{Section 1}](#data). [\textcolor{blue}{Section 2}](#desc-anal) contains a diachronic descriptive analysis of the mobility network that highlights shared and different properties of the networks through time. Inside [\textcolor{blue}{Section 3}](#comm-det), we apply highlight mobility shifts at a provincial level by the means of well-established community detection algorithms. [\textcolor{blue}{Section 4}](#modeling) contains our efforts in modeling the mobility network by the means of exponential random graphs (ERGs) to show the strong connection between mobility shifts and COVID-19 spreading statistics. We conclude in [\textcolor{blue}{Section 5}](#conclusion) by comparing our results with the mobility reports publicly released by Google during the lockdown and summarizing our findings.

## [1. Data and Preprocessing]{#data}

The datasets contains the estimated raw number of movements *n* in 3 days during the Covid crisis, filtered by country = IT. The 3 days refers to  In this dataset are present different metric to estimate movements, we have selected the metric *n* because it represents a kind of measure of popularity.

## [2. Diachronic Descriptive Analysis of Mobility Networks]{#desc-anal}

A first insight is given by the sum of the movements in these 3 days. We notice that mobility doesn't change much allowing intra-provincial movements, since inter-province connections have values that are much lower than intra-province ones. Thus, removing the loops, allow us to see only inter-province movements and in this case the mobility is significantly lower:

```{r echo = FALSE}
print(paste("Movements (inter-province): Pre", round(sum(E(graph_pre)$weight)), " -> Mid", 
            round(sum(E(graph_mid)$weight)), " -> Post", round(sum(E(graph_post)$weight))))
```
A graphical representation of this phenomenon is given by Fig 1.

*PLOTTARE 3 IMMAGINI CHE COMPONGONO LA GIF*

We restrict our attention to inter-province movments for the descriptive analysis, since they capture better the variation of mobility and the results for intra-province are empirically quite similar. The graphs are **directed**, **weighted** (accoriding to the metric value) and **disconnected** (this is valid for both implementations).

From the in-degree and out-degree distribution of the 3 graphs, it is highlighted that the majority of nodes have degree between 1 and 10, with few nodes that assumes bigger values. We can notice that, for in-degree, large values tends to vanish and the distribution concentrates to small values, indicating that nodes loose their popularity through time. The same happens to the out-degree distribution, idicating that also expansiveness of nodes tends to reduce.

```{r echo = FALSE, fig.height=2}
V(graph_pre)$deg <- igraph::degree(graph_pre) 
V(graph_pre)$ideg <- igraph::degree(graph_pre, mode="in")   
V(graph_pre)$odeg <- igraph::degree(graph_pre, mode="out")

V(graph_mid)$deg <- igraph::degree(graph_mid) 
V(graph_mid)$ideg <- igraph::degree(graph_mid, mode="in") 
V(graph_mid)$odeg <- igraph::degree(graph_mid, mode="out")

V(graph_post)$deg <- igraph::degree(graph_post) 
V(graph_post)$ideg <- igraph::degree(graph_post, mode="in") 
V(graph_post)$odeg <- igraph::degree(graph_post, mode="out")

par(mfrow=c(1,4))
hist(get_attr(graph_pre, "ideg", "vertex"), xlab ="In-Degree distribution", ylab="# of Provinces", main = "Mobility pre lock.", breaks=15)
hist(get_attr(graph_post, "ideg", "vertex"), xlab ="In-Degree distribution", ylab="# of Provinces", main = "Mobility post lock.", breaks=15)
hist(get_attr(graph_pre, "odeg", "vertex"), xlab ="Out-Degree distribution", ylab="# of Provinces", main = "Mobility pre lock.", breaks=15)
hist(get_attr(graph_post, "odeg", "vertex"), xlab ="Out-Degree distribution", ylab="# of Provinces", main = "Mobility post lock.", breaks=15)

```

The **network density**, presented in Table 1, indicates, first, that the graph are **sparse**, since the very low values that assumes this quantity, and second, that the denisty reduces over time, indicating, like the in-degree and out-degree distributions, that the movements significantly decreases between the provinces through time.

In order to implement centrality measures, we have to invert the weights of our graphs. This have to be done because actual weights represent a sort of strength measure between nodes, not a distance(cost) measure. After that we can calculate the **betweenness** and the **eigenvector centrality** for the graphs. Note that the closeness will be calculated later, because this measure is only meaningful in a connected graph.

The betweenness remains practically the same in all the three graphs, apart from a few small variations. Hovewer in Lazio, Umbria and Abruzzo happens an interesting thing. Before lockdown, Rome has the largest value with respect to neighboring provinces, but as the time passes, its value tends to reduce and the other neighboring provinces tend to assume higher values. 
This could indicate that Rome's tendency to influence movements (flows) is slightly lost in favor of its neighbors. 

*PLOT BTWN SUBGRAPH IN LAZIO,UMBRIA E ABRUZZO*

Eigenvector centrality shows that there is a loss of influence over the whole network by provinces 
in the provice of northern and southern Italy, while in central Italy the situation remains almost completely unchanged, despite a slight decrease in values.

*PLOT EIGE_VECT SUBGRAPH IN TUTTA ITALIA*

For what it concerns about **assortativity by degree**, we calculate this measure for the graphs and, as reported in Table 1, we can see that in the mobility pre-lockdown we have a small positive value of $0.134$ that indicates the sligth tendency of nodes of similar degree to connect with each others. An interesting fact is that this measure increases through time, reaching a value of $0.326$. This could indicate that the movements have concentrated more between provinces of the same degree, reducing the movement from "small" to "large" ones.

The **global clustering coefficient**, that refers to netowrk cohesion analysis, is calculated:

 - **Globally**
 - on **subgraphs** in which all the nodes have a weight that is above or below a fixed **threshold**.
 - in  **k-cores components** of original graphs.
 
As reported in Table 1, the **transitivity** for the whole network tends to remain the same, except for a small increase that isn't significant. Thus, to inspect better this property, we calculate this measure on two subgraphs obtained placing a $threshold_w = 500$ on weights. The value that we choose is based on the distribution of weights in the network, noticing that most part of nodes  have weights that go from $0$ to $500$. As we can notice from the results presented in the table, for the subgraphs of nodes below the threshold, the transitivity, that is smaller with respect the global value, reamins again pratically the same, instead for the other subgraph there is a significant increment of $0.10$. This could mean that big provinces tends to increase their connections through the three different phases of lockdown. We have also calculated this index on k-cores of the graph, selecting as k the minimum value between the three coreness value, resulting in $k = 8$ (notice that only the graph referred to the mobility pre-lockdown has a value of k bigger than the selected, with the coreness equal to $10$). The transitivity calculated on these maximal subgraphs has a significant decrease of $0.18$, as we expected, indicating that these subgraphs have a loss in terms of cohesion through the time.
 
```{r echo = FALSE}
assort_pre <- assortativity_degree(graph_pre,directed = TRUE)
assort_mid <- assortativity_degree(graph_mid,directed = TRUE)
assort_post <- assortativity_degree(graph_post,directed = TRUE)

denisty_pre <- igraph::edge_density(graph_pre, loops = FALSE)
density_mid <- igraph::edge_density(graph_mid, loops = FALSE)
denisty_post <- igraph::edge_density(graph_post, loops = FALSE)

gloabl_tran_pre <- transitivity(graph_pre,weights = E(graph_pre)$inverted_weight)
gloabl_tran_mid <- transitivity(graph_mid, weights = E(graph_mid)$inverted_weight)
gloabl_tran_post <- transitivity(graph_post, weights = E(graph_post)$inverted_weight)

w_threshold <- 500
sub_pre_weight_up<- subgraph.edges(graph_pre, E(graph_pre)[E(graph_pre)$weight>w_threshold],delete.vertices = TRUE )
sub_mid_weight_up<- subgraph.edges(graph_mid, E(graph_mid)[E(graph_mid)$weight>w_threshold],delete.vertices = TRUE )
sub_post_weight_up<- subgraph.edges(graph_post, E(graph_post)[E(graph_post)$weight>w_threshold],delete.vertices = TRUE )

# Obtain transitivity for the subgraph of nodes which have larger weight than the threshold
tran_sub_pre_weight_up <- transitivity(sub_pre_weight_up,weights = E(sub_pre_weight_up)$inverted_weight)
tran_sub_mid_weight_up <- transitivity(sub_mid_weight_up, weights = E(sub_mid_weight_up)$inverted_weight)
tran_sub_post_weight_up <- transitivity(sub_post_weight_up, weights = E(sub_post_weight_up)$inverted_weight)

sub_pre_weight_lo<- subgraph.edges(graph_pre, E(graph_pre)[E(graph_pre)$weight<=w_threshold],delete.vertices = TRUE )
sub_mid_weight_lo<- subgraph.edges(graph_mid, E(graph_mid)[E(graph_mid)$weight<=w_threshold],delete.vertices = TRUE )
sub_post_weight_lo<- subgraph.edges(graph_post, E(graph_post)[E(graph_post)$weight<=w_threshold],delete.vertices = TRUE )

tran_sub_pre_weight_lo <- transitivity(sub_pre_weight_lo,weights = E(sub_pre_weight_lo)$inverted_weigh)
tran_sub_mid_weight_lo <- transitivity(sub_mid_weight_lo, weights = E(sub_mid_weight_lo)$inverted_weigh)
tran_sub_post_weight_lo <- transitivity(sub_post_weight_lo, weights = E(sub_post_weight_lo)$inverted_weigh)

coreness_pre <- graph.coreness(graph_pre) 
coreness_mid <- graph.coreness(graph_mid)
coreness_post <- graph.coreness(graph_post) 
selected_coreness <- min(max(coreness_pre),max(coreness_mid), max(coreness_post))
kcore_pre <- induced.subgraph(graph_pre,vids=which(coreness_pre == selected_coreness))
kcore_mid <- induced.subgraph(graph_mid,vids=which(coreness_mid == selected_coreness))
kcore_post <- induced.subgraph(graph_post,vids=which(coreness_post == selected_coreness))

# Compute transitiity in the k cores subgraphs
tran_sub_pre_kcore <- transitivity(kcore_pre,weights = NULL)
tran_sub_mid_kcore <- transitivity(kcore_mid, weights = NULL)
tran_sub_post_kcore <- transitivity(kcore_post, weights = NULL)

m <- matrix(nrow = 6, ncol = 3)
colnames(m) <- c("Pre-lock.", "Mid-lock.", "Post-lock.")
rownames(m) <- c("Density", "Assortativity by degree ", "Transitivity Glo.","Transitivity sub. upper","Transitivity sub. lower", "Transitivity k-cores" )
m[1,] <- as.array(c(denisty_pre,density_mid,denisty_post))
m[2,] <- as.array(c(assort_pre,assort_mid,assort_post))
m[3,] <- as.array(c(gloabl_tran_pre,gloabl_tran_mid,gloabl_tran_post))
m[4,] <- as.array(c(tran_sub_pre_weight_up,tran_sub_mid_weight_up,tran_sub_post_weight_up))
m[5,] <- as.array(c(tran_sub_pre_weight_lo,tran_sub_mid_weight_lo,tran_sub_post_weight_lo))
m[6,] <- as.array(c(tran_sub_pre_kcore,tran_sub_mid_kcore,tran_sub_post_kcore))

knitr::kable(
  m, caption = 'Descrpitive analysis measures',format = "latex"
)

```
## [3. Detecting Mobility Communities]{#comm-det}



## [4. Modeling Mobility Patterns]{#modeling}

## [5. Discussion and Conclusion]{#conclusion}

\blandscape

# [Appendix]{#appendix}

## [A. Coreness Plots for Feb. 25th, 2020 Mobility Network]{#coreness}

\vspace{5mm}

\begin{figure}
\begin{center}
\includegraphics{img/coreness.png}
\caption{Finding the .rproj file for Chapter 3}
\label{coreness}
\end{center}
\end{figure}

\newpage

## [B. Weighted Coreness Plots for Feb. 25th, 2020 Mobility Network]{#wcoreness}

\vspace{5mm}

\begin{figure}
\begin{center}
\includegraphics{img/weighted_coreness.png}
\caption{Finding the .rproj file for Chapter 3}
\label{wcoreness}
\end{center}
\end{figure}

\newpage

## [C. Connected Components and Cliques for the Three Lockdown Phases]{#components}

\vspace{5mm}

\begin{figure}
\begin{center}
\includegraphics{img/comp_cliques.png}
\caption{Finding the .rproj file for Chapter 3}
\label{comp_cliques}
\end{center}
\end{figure}

\newpage

## [C. Community Detection using Girvan-Newman Algorithm and Label Propagation]{#components}

\vspace{5mm}

\begin{figure}
\begin{center}
\includegraphics{img/clustering.png}
\caption{Finding the .rproj file for Chapter 3}
\label{clustering}
\end{center}
\end{figure}

\elandscape

## [D. Regions of middle Italy where the size of each vertex is proportional to betweenness]{#betweenness}

\vspace{5mm}

\begin{figure}
\begin{center}
\includegraphics{img/btw_regions.PNG}
\caption{Finding the .rproj file for Chapter 3}
\label{betweenness}
\end{center}
\end{figure}

## [E. Network graphs where the size of each vertex is proportional to eigenvector centrality]{#eigenvector_centrality}

\vspace{5mm}

\begin{figure}
\begin{center}
\includegraphics{img/eig_vect_italy.png}
\caption{Finding the .rproj file for Chapter 3}
\label{eigenvector centrality}
\end{center}
\end{figure}

\newpage